\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{latexsym,amsfonts,amssymb,amsthm,amsmath}
\usepackage{indentfirst} % To indent the first paragraph of a section
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage[hidelinks]{hyperref} % For better cross-referencing

\geometry{a4paper, margin=1in}

\graphicspath{ {./images/} }

% \setlength{\parindent}{0in} % Disabling this to allow for standard indentation
\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.8in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{18pt}

% Settings for code listings
\lstset{
  mathescape,
  backgroundcolor=\color{gray!10},
  basicstyle=\ttfamily,
  columns=fullflexible,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{green},
  extendedchars=true,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=c++,
  numbers=none,
  numbersep=5pt,
  numberstyle=\tiny\color{blue},
  rulecolor=\color{gray},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=5,
  stringstyle=\color{red},
  tabsize=3,
  title=\lstname
}

\title{Home assignment for Computer Network EDA387}
\author{Group 24}

\begin{document}

\maketitle

\vspace{0.5in}

\begin{algorithm}[H]
\caption{Reliable Flooding for disseminating Link State Packets (LSPs) across a network.}
\label{alg:flooding}
\begin{algorithmic}[1]
    \State Each node stores the latest Link State Packet (LSP) from every other node.
    \State LSPs are forwarded to all nodes except the sender, preventing unnecessary retransmissions.
    \State Periodic generation of new LSPs occurs, with an incremented Sequence Number (SEQNO). After a reboot, SEQNO starts at 0.
    \State Upon hearing an LSP with SEQNO = $x$, a node sets its next SEQNO to $x+1$.
    \State Stored LSPs' Time-to-Live (TTL) decreases; LSPs expire when TTL reaches 0.
\end{algorithmic}
\end{algorithm}

\section*{4 The Link State Algorithm and Self-stabilization}

The Link State algorithm involves sending information not only to neighbors but to all network nodes.
This question asks whether the link state algorithm is self-stabilizing or can become one.
Algorithm~\ref{alg:flooding} sketches the protocol for reliable flooding, as we learned in class.
We clarify that the Link State algorithm also uses a local calculation.
That is, the flooding method described in Algorithm~\ref{alg:flooding} supplies the link state
algorithm with a set of LSPs for each SEQNO. Using Dijkstra's shortest path algorithm, this link state
algorithm enables each node to calculate the shortest path within a given graph locally.

\subsection*{Question 1.}
\begin{itemize}
    \item What is the model used by the Link-State algorithm? Please choose the most appropriate, correct, complete, and accurate answer.
    If you think there is more than one correct answer, select the ones that can help you simplify your answer to the rest of this question.
    Clearly justify your selection.
    
    \begin{enumerate}
        \item Asynchronous shared memory network with the topology of the fully connected graph with fair communication.
        
        \item Synchronous message-passing network with the topology of general graph and reliable communication channels.
        
        \item Synchronous message-passing network with the topology of the general graph with fair execution.
        
        \item Asynchronous message-passing network with the topology of the general graph with fair communication.
        
        \item Synchronous shared memory network with topology of fully connected graph and fair communications.
    \end{enumerate}

    \item Please provide a detailed pseudo code for reliable flooding, which is used by the Link State Algorithm.
    Your pseudo-code should consider the model you selected above.

    \item Discuss the self-stabilization properties of the algorithm you have provided above.
    A simple 'yes' or 'no' response is insufficient for credit; your answer should demonstrate
    a comprehensive understanding of the topic. For example, you may analyze how the algorithm
    behaves when initiated from an arbitrary starting state (related to the link-state algorithm),
    highlighting potential disruptions in network operation without the ability to self-recover.
    Conversely, if you believe the algorithmis self-stabilizing, you can outline a correctness
    proof while emphasizing its key assumptions.
\end{itemize}


\bigskip

\begin{proof}

For the model choosing, the most appropriate model to chose is the model 4, \textit{Asynchronous message-passing
network with the topology of the general graph with fair communication.}, for the justifying:

\begin{itemize}
    \item \textbf{Asynchronous} because in the Internet, all the nodes (or routers) act at their own pace, there is
    no a central clock for all these nodes. The time for a message from a node to another one is unpredictable, so we
    cannot use the synchronous one, because it contains restriction that is not correct in comparison with actual
    network model.
    \item \textbf{Messenger-passing} as stated before, because every nodes have their own clock, hence, own memory, it
    is impossible to have a shared memory between these nodes. Moreover, in a large network, nodes are added and removed
    quite frequently, a model that has a central memory will require more operation overhead to maintain, manage as well as
    to response to the network changes. All nodes in real topology communicate by sending and recieving messages over physical
    link.
    \item \textbf{General graph} in the real model, the network topology is not always clear, therefore, an algorithm and periodically
    flooding from neighbor nodes are require to discover the paths between these nodes.
    \item \textbf{Fair communication} is a realistic assumption. It states that if a message is sent infinitely, it will be received infinitely.
    On the other hand, even there are loss in communication channels, the Link State Protocol and algorithm are able to handle this loss, hence
    retransmit these packets.
\end{itemize}

\begin{algorithm}[H]
\caption{Pseudocode for Reliable Flooding of LSPs}
\label{alg:reliable_flooding}
\begin{algorithmic}[1]
    \State \textbf{Initialization for node $P_i$:}
    \State $SEQNO_i \gets 0$
    \State $N(i) \gets \text{set of neighbors}$
    \State $LSP[] \gets \emptyset$
    
    \Procedure{PeriodicUpdate}{}
        \Loop
            \State $SEQNO_i \gets SEQNO_i + 1$
            \State $LSP_i \gets \textit{generateLSP}(i, SEQNO_i, \textit{$TTL_i$})$
            \State $LSP[i] \gets LSP_i$
            \ForAll{neighbor $P_j \in N(i)$}
                \State send $\langle i, LSP[i] \rangle$ to $P_j$
            \EndFor
        \EndLoop
    \EndProcedure
    
    \Procedure{OnReceive}{$\langle j, LSP_j \rangle$ from neighbor $P_j$}
        \If{$LSP_j \notin LSP[]$ \textbf{or} $SEQNO_j > LSP[j].SEQNO$}
            \State $LSP[j] \gets LSP_j$
            \State $SEQNO_i \gets SEQNO_j + 1$
            \ForAll{neighbor $P_k \in N(i)$ such that $k \neq s$}
                \State send $\langle j, LSP_j \rangle$ to $P_k$
            \EndFor
        \EndIf
    \EndProcedure

    \Procedure{DecrementTTL}{}
        \Loop
            \ForAll{$\langle j, LSP_j \rangle$ in $LSP[]$}
                \State $\textit{LSP}_j.\textit{TTL} \gets \textit{LSP}_j.\textit{TTL} - 1$
                \If{$\textit{LSP}_j.\textit{TTL} \le 0$}
                    \State remove $\langle j, LSP_j \rangle$ from $LSP[]$
                \EndIf
            \EndFor
        \EndLoop
    \EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection*{Discussion on Self-Stabilization}

Let's consider that the system starts with an arbitrary status, where nodes can send wrong Link-State package, or the packet is loss during transmission. In this algorithm, $SEQNO$ and $TTL$ can be used to ensure the fault does not stay in the system forever.

In the pseudo code, when a node/processor $P_i$ receives a LSP (line 16-19), considered that the packet contained fault information. But due to the flooding nature of this algorithm, $P_i$ will receive a new packet from its neighbors, after a comparison, it keeps the packet with higher $SEQNO$ (and plus 1, remarks that is an asynchronous round).

From the start, or restart event, every nodes have $SEQNO = 0$, means that they will accept any LSP packet with higher number. This ensure when a new node joins this network or a node that just recovered from fault can keep up with latest network topology.

Moreover, due to \textit{fair communication}, the new, correct LSP will be eventually passed to all other nodes. And because LSP is periodically generated with a higher $SEQNO$ (line 6-9), the correct (and newer) LSP is always accepted.

Finally, the $TTL$ can ensure that even without new LSP, or the arbitrary status lasts longer than expected, node will drop expired LSP information. Every time it receives new LSP or completing a round, it can decrease the $TTL$ of stored LSP information, hence remove the stale one when TTL drops to 0.

The safe configuration of this system is when all the nodes have the latest LSP information.

\end{proof}

\section*{Question 2.}

Please offer a self-stabilizing solution to the problem addressed by the Link State algorithm within the context of an asynchronous shared memory network, with a general graph topology and fair execution.
\begin{itemize}
    \item Your solution should encompass its own pseudocode, which may leverage concepts and algorithms learned in class. In that case, please cite them clearly using the exact book chapter and section numbers.
    \item Additionally, provide a self-contained correctness proof, referencing relevant theorems and lemmas explicitly if utilized.
\end{itemize}


\begin{algorithm}[H]
\caption{Token-Based Link-State Packet Dissemination}
\label{alg:token_lsp}
\begin{algorithmic}[1]
    \State \textbf{Structure} to store Link State Packet:
    \Statex \hspace{\algorithmicindent} \textbf{node} \{
    \Statex \hspace{\algorithmicindent} \hspace{\algorithmicindent} \textit{seqno}; \Comment{Sequence number}
    \Statex \hspace{\algorithmicindent} \hspace{\algorithmicindent} \textit{lsp}; \Comment{Link state packet}
    \Statex \hspace{\algorithmicindent} \hspace{\algorithmicindent} \textit{token}; \Comment{Token presence indicator}
    \Statex \hspace{\algorithmicindent} \}
    
    \Procedure{OnReceiveToken}{}
        \State $seqno \gets 0$; \Comment{Node's sequence number is set to zero}
        \State $lsp \gets \Call{GenerateLSP}{}$;
        \State $token \gets \text{true}$;
        \State send $token$ to next\_node;
    \EndProcedure
    \Statex
    
    \Procedure{OnTimerExpired}{}
        \State $lsp \gets \Call{GenerateLSP}{}$;
        \State $seqno \gets seqno + 1$;
        \ForAll{each neighbor}
            \State send $\langle lsp, seqno \rangle$ to neighbor;
        \EndFor
    \EndProcedure
    \Statex
    
    \Procedure{OnReceiveLSP}{$\langle lsp, seqno \rangle$ from neighbor}
        \If{$seqno > \text{stored\_seqno}$}
            \State $\text{stored\_seqno} \gets seqno$;
            \State $\text{stored\_lsp} \gets lsp$;
            \State \Call{UpdateRoutingTable}{};
        \EndIf
    \EndProcedure
    
\end{algorithmic}
\end{algorithm}

\begin{proof}
    Because these nodes (processors) use a shared memory, we have a $token$ to ensure that only
    a node can enter the \textit{critical selection} at a time. The main idea is that, a node can
    upon receiving a token, the node can generate $LSP$ packet, sends to neighbors and also passes 
    the token.

    \begin{itemize}
        \item \textbf{Safe configuration and legal execution} for this model, when all nodes keep
        the most recently data (the LSP packet that still has TTL and with the highest SEQNO), or
        with two neighbor nodes $P_i$ and $P_j$, the LSP from each of these node should have the
        same SEQNO. From this state, only $expired$ and $receiveToken$ can happen.
        \item \textbf{Proof of correctness} when receiving the token, a node set its SEQNO to 0 and 
        passed the token to neighbors, allow other nodes to generate LSP. In addition, if the system
        started on arbitrary state, the fault LSP packet will be erased because of the procedure $OnTimerExpired$,
        each node will generate new LSP and increase the SEQNO to 1. On the receiver side, when it
        has a LSP packet from its neighbor, if the SEQNO of that packet is larger that the one it has,
        it will perform an update. This ensure that the LSP data will be frequently refreshed and only
        the newer is kept (line 16). Moreover, in the $OnReceiveToken$, we see that if the system is down,
        $token$ will be passed to all nodes and they will begin a new procedure of generating LSP and broadcasting
        to all.
        \item \textbf{Convergence} because in this general graph, with fair execution, once a node sends
        a LSP, it will be propagated to all other nodes. With the constrain in the $SEQNO$, any stale LSP
        will be replaced.
    \end{itemize}
\end{proof}

\section*{Question 3: Comparison of Link-State Algorithms}

\subsection*{Advantages}
\begin{itemize}
    \item \textbf{Original Link-State Algorithm:} It is efficient, scalable, and well-established, which has led to its wide use in production networks.
    
    \item \textbf{Self-Stabilizing Link-State Algorithm:} Its primary advantage is its inherent fault tolerance. The algorithm is self-stabilizing, meaning it can automatically recover from arbitrary transient faults without external intervention.
\end{itemize}

\subsection*{Disadvantages}
\begin{itemize}
    \item \textbf{Original Link-State Algorithm:} The main drawback is its lack of self-stabilization. It can be vulnerable to transient faults that corrupt routing tables, and it often requires significant manual configuration and careful management to operate reliably.
    
    \item \textbf{Self-Stabilizing Link-State Algorithm:} The robustness comes at a cost. These algorithms are typically more complex in their design and can be significantly harder to implement, verify, and debug compared to their non-stabilizing counterparts.
\end{itemize}

\end{document}
% vim: set ts=4 sw=4 et:

